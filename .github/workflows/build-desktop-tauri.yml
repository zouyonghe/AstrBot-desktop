name: Build Desktop Tauri

on:
  workflow_dispatch:
    inputs:
      source_git_url:
        description: AstrBot source git URL
        required: false
        default: https://github.com/AstrBotDevs/AstrBot.git
      source_git_ref:
        description: AstrBot source git ref (branch/tag/sha), empty means default ref
        required: false
        default: ""
      publish_release:
        description: Publish GitHub Release after successful builds
        required: false
        type: boolean
        default: true
  schedule:
    - cron: '0 * * * *'

permissions:
  contents: read

env:
  ASTRBOT_SOURCE_GIT_URL: ${{ vars.ASTRBOT_SOURCE_GIT_URL || 'https://github.com/AstrBotDevs/AstrBot.git' }}
  ASTRBOT_SOURCE_GIT_REF: ${{ vars.ASTRBOT_SOURCE_GIT_REF || 'master' }}

jobs:
  resolve_build_context:
    name: Resolve Build Context
    runs-on: ubuntu-latest
    outputs:
      source_git_url: ${{ steps.resolve.outputs.source_git_url }}
      source_git_ref: ${{ steps.resolve.outputs.source_git_ref }}
      astrbot_version: ${{ steps.resolve.outputs.astrbot_version }}
      should_build: ${{ steps.resolve.outputs.should_build }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.2

      - name: Setup Toolchains
        uses: ./.github/actions/setup-toolchains
        with:
          setup-node: 'false'
          python-version: '3.12'

      - name: Resolve source, version and trigger guard
        id: resolve
        env:
          ASTRBOT_SOURCE_GIT_URL: ${{ env.ASTRBOT_SOURCE_GIT_URL }}
          ASTRBOT_SOURCE_GIT_REF: ${{ env.ASTRBOT_SOURCE_GIT_REF }}
          WORKFLOW_SOURCE_GIT_URL: ${{ github.event.inputs.source_git_url }}
          WORKFLOW_SOURCE_GIT_REF: ${{ github.event.inputs.source_git_ref }}
          GITHUB_TOKEN: ${{ github.token }}
          GH_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
        run: |
          set -euo pipefail

          source_git_url="${ASTRBOT_SOURCE_GIT_URL}"
          source_git_ref="${ASTRBOT_SOURCE_GIT_REF}"
          should_build="true"

          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            if [ -n "${WORKFLOW_SOURCE_GIT_URL:-}" ]; then
              source_git_url="${WORKFLOW_SOURCE_GIT_URL}"
            fi
            if [ -n "${WORKFLOW_SOURCE_GIT_REF:-}" ]; then
              source_git_ref="${WORKFLOW_SOURCE_GIT_REF}"
            fi
          fi

          if [ "${GITHUB_EVENT_NAME}" = "schedule" ]; then
            latest_tag="$(git ls-remote --tags --refs "${source_git_url}" \
              | awk '{print $2}' \
              | sed 's#refs/tags/##' \
              | sort -V \
              | tail -n 1)"
            if [ -z "${latest_tag}" ]; then
              echo "Unable to resolve latest tag from ${source_git_url}" >&2
              exit 1
            fi
            source_git_ref="${latest_tag}"
            echo "Scheduled run detected latest upstream tag: ${source_git_ref}"

            http_status="$(curl -sS -o /dev/null -w '%{http_code}' \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${GH_REPOSITORY}/releases/tags/${source_git_ref}")"
            if [ "${http_status}" = "200" ]; then
              should_build="false"
              echo "Release ${source_git_ref} already exists. Tag unchanged, skipping build."
            else
              echo "Release ${source_git_ref} not found (HTTP ${http_status}). Build will run."
            fi
          fi

          version=""
          if [ "${should_build}" = "true" ]; then
            if printf '%s' "${source_git_ref}" | grep -Eq '^v[0-9]+(\.[0-9]+){1,2}([.-][0-9A-Za-z.-]+)?$'; then
              version="${source_git_ref#v}"
              echo "Resolved version directly from source tag: ${source_git_ref}"
            else
              workdir="$(mktemp -d)"
              repo_dir="${workdir}/AstrBot"
              git init "${repo_dir}"
              git -C "${repo_dir}" remote add origin "${source_git_url}"
              git -C "${repo_dir}" fetch --depth 1 origin "${source_git_ref}"
              git -C "${repo_dir}" checkout --detach FETCH_HEAD
              version="$(python3 scripts/ci/read-project-version.py "${repo_dir}/pyproject.toml")"
            fi
          else
            version="${source_git_ref#v}"
            if [ -z "${version}" ] || [ "${version}" = "${source_git_ref}" ]; then
              version="unknown"
            fi
          fi

          {
            echo "source_git_url=${source_git_url}"
            echo "source_git_ref=${source_git_ref}"
            echo "astrbot_version=${version}"
            echo "should_build=${should_build}"
          } >> "${GITHUB_OUTPUT}"
          echo "Resolved source: ${source_git_url}@${source_git_ref}"
          echo "Resolved AstrBot version: ${version}"
          echo "Build enabled: ${should_build}"

  sync_repo_version:
    name: Sync Repository Version
    needs: resolve_build_context
    if: ${{ needs.resolve_build_context.outputs.should_build == 'true' && github.event_name == 'schedule' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout branch
        uses: actions/checkout@v6.0.2
        with:
          fetch-depth: 0
          ref: ${{ github.ref_name }}

      - name: Setup Toolchains
        uses: ./.github/actions/setup-toolchains
        with:
          setup-python: 'false'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4.2.0
        with:
          version: 10.28.2

      - name: Sync desktop version to upstream tag
        env:
          ASTRBOT_SOURCE_GIT_URL: ${{ needs.resolve_build_context.outputs.source_git_url }}
          ASTRBOT_SOURCE_GIT_REF: ${{ needs.resolve_build_context.outputs.source_git_ref }}
          ASTRBOT_DESKTOP_VERSION: ${{ needs.resolve_build_context.outputs.astrbot_version }}
        run: make update

      - name: Commit and push version files
        env:
          ASTRBOT_VERSION: ${{ needs.resolve_build_context.outputs.astrbot_version }}
          TARGET_REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail

          changed_files="$(git status --porcelain -- package.json src-tauri/Cargo.toml src-tauri/tauri.conf.json)"
          if [ -z "${changed_files}" ]; then
            echo "Version files are already up to date. Nothing to commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add package.json src-tauri/Cargo.toml src-tauri/tauri.conf.json
          git commit -m "chore(version): sync desktop version to v${ASTRBOT_VERSION}"

          git fetch origin "${TARGET_REF_NAME}"
          if ! git pull --rebase origin "${TARGET_REF_NAME}"; then
            echo "::warning::Failed to rebase onto origin/${TARGET_REF_NAME}. Skipping push to avoid noisy failures."
            git rebase --abort || true
            exit 0
          fi

          if ! git push origin "HEAD:${TARGET_REF_NAME}"; then
            echo "::warning::Push to ${TARGET_REF_NAME} was rejected (likely branch protection or race). Skipping."
            exit 0
          fi

  build-linux:
    needs:
      - resolve_build_context
      - sync_repo_version
    if: ${{ always() && needs.resolve_build_context.outputs.should_build == 'true' && (needs.sync_repo_version.result == 'success' || needs.sync_repo_version.result == 'skipped') }}
    name: linux-${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
          - arch: arm64
            runner: ubuntu-24.04-arm

    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.2

      - name: Install Linux dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Setup desktop build environment
        uses: ./.github/actions/setup-desktop-build

      - name: Build desktop installers (Linux)
        env:
          ASTRBOT_SOURCE_GIT_URL: ${{ needs.resolve_build_context.outputs.source_git_url }}
          ASTRBOT_SOURCE_GIT_REF: ${{ needs.resolve_build_context.outputs.source_git_ref }}
          ASTRBOT_DESKTOP_VERSION: ${{ needs.resolve_build_context.outputs.astrbot_version }}
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ github.token }}
        run: cargo tauri build --bundles deb,rpm

      - name: Upload artifacts
        uses: actions/upload-artifact@v6.0.0
        with:
          name: astrbot-desktop-tauri-${{ needs.resolve_build_context.outputs.astrbot_version }}-linux-${{ matrix.arch }}
          if-no-files-found: error
          path: |
            src-tauri/target/release/bundle/**/*.deb
            src-tauri/target/release/bundle/**/*.rpm

  build-macos:
    needs:
      - resolve_build_context
      - sync_repo_version
    if: ${{ always() && needs.resolve_build_context.outputs.should_build == 'true' && (needs.sync_repo_version.result == 'success' || needs.sync_repo_version.result == 'skipped') }}
    name: macos-${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: macos-15-intel
            target: x86_64-apple-darwin
          - arch: arm64
            runner: macos-latest
            target: aarch64-apple-darwin

    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.2

      - name: Setup desktop build environment
        uses: ./.github/actions/setup-desktop-build

      - name: Build desktop installers (macOS)
        id: build_macos
        continue-on-error: true
        env:
          ASTRBOT_SOURCE_GIT_URL: ${{ needs.resolve_build_context.outputs.source_git_url }}
          ASTRBOT_SOURCE_GIT_REF: ${{ needs.resolve_build_context.outputs.source_git_ref }}
          ASTRBOT_DESKTOP_VERSION: ${{ needs.resolve_build_context.outputs.astrbot_version }}
          ASTRBOT_DESKTOP_CRYPTOGRAPHY_FALLBACK_VERSIONS: ${{ vars.ASTRBOT_DESKTOP_CRYPTOGRAPHY_FALLBACK_VERSIONS || '' }}
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          set -euo pipefail

          max_attempts=3
          attempt=1
          # Only retry on known transient DMG detach failures.
          retry_pattern='hdiutil: detach:.*(timeout|not detached)|DiskArbitration expired'
          detach_attempts=3
          detach_sleep_seconds=2
          rw_dmg_image_prefix='/src-tauri/target/'
          rw_dmg_image_suffix_regex='/bundle/macos/rw\..*\.dmg$'
          # hdiutil temporary writable images often mount under /Volumes/dmg.*,
          # but macOS/tauri naming can vary; keep this pattern configurable.
          rw_dmg_mountpoint_regex="${ASTRBOT_DESKTOP_MACOS_RW_DMG_MOUNT_REGEX:-^/Volumes/(dmg\\.|rw\\.|dmg-|rw-)}"
          allow_global_helper_cleanup="${ASTRBOT_DESKTOP_MACOS_ALLOW_GLOBAL_HELPER_KILL:-0}"
          log_file=""
          workspace_root="${GITHUB_WORKSPACE:-$(pwd)}"
          workspace_root="${workspace_root%/}"
          declare -a canonical_path_cache_keys=()
          declare -a canonical_path_cache_values=()

          cleanup_log_file() {
            if [ -n "${log_file:-}" ]; then
              rm -f "${log_file}" || true
              log_file=""
            fi
          }
          trap cleanup_log_file EXIT

          detach_target() {
            local target="$1"
            local pass=1
            while [ "${pass}" -le "${detach_attempts}" ]; do
              if hdiutil detach "${target}"; then
                return 0
              fi
              hdiutil detach -force "${target}" || true
              sleep "${detach_sleep_seconds}"
              pass=$((pass + 1))
            done
            echo "WARN: Failed to detach ${target} after ${detach_attempts} attempts" >&2
            return 1
          }

          canonicalize_path() {
            local raw_path="$1"
            local idx
            for idx in "${!canonical_path_cache_keys[@]}"; do
              if [ "${canonical_path_cache_keys[$idx]}" = "${raw_path}" ]; then
                printf '%s\n' "${canonical_path_cache_values[$idx]}"
                return 0
              fi
            done

            local resolved_path
            if ! resolved_path="$(python3 -c 'import os,sys; print(os.path.realpath(sys.argv[1]))' "${raw_path}" 2>/dev/null)"; then
              resolved_path="${raw_path}"
            fi
            canonical_path_cache_keys+=("${raw_path}")
            canonical_path_cache_values+=("${resolved_path}")
            printf '%s\n' "${resolved_path}"
          }

          workspace_root_canonical="$(canonicalize_path "${workspace_root}")"
          workspace_root_canonical="${workspace_root_canonical%/}"

          is_workspace_rw_dmg_image() {
            local image="$1"
            local normalized_image
            normalized_image="$(canonicalize_path "${image}")"
            local candidate
            for candidate in "${image}" "${normalized_image}"; do
              candidate="${candidate%/}"
              if [[ "${candidate}" == "${workspace_root}${rw_dmg_image_prefix}"* ]] &&
                 [[ "${candidate}" =~ ${rw_dmg_image_suffix_regex} ]]; then
                return 0
              fi
              if [[ -n "${workspace_root_canonical}" ]] &&
                 [[ "${candidate}" == "${workspace_root_canonical}${rw_dmg_image_prefix}"* ]] &&
                 [[ "${candidate}" =~ ${rw_dmg_image_suffix_regex} ]]; then
                return 0
              fi
            done
            return 1
          }

          collect_dmg_records() {
            hdiutil info 2>/dev/null | awk '
              BEGIN { image = ""; dev = ""; pid = "" }
              /^image-path[[:space:]]*:/ {
                line = $0
                sub(/^image-path[[:space:]]*:[[:space:]]*/, "", line)
                image = line
                next
              }
              /^\/dev\/disk[0-9]+/ && dev == "" {
                dev = $1
                next
              }
              /^process ID[[:space:]]*:/ {
                line = $0
                sub(/^process ID[[:space:]]*:[[:space:]]*/, "", line)
                pid = line
                next
              }
              /^=+/ {
                if (image != "") {
                  print image "\t" dev "\t" pid
                }
                image = ""
                dev = ""
                pid = ""
                next
              }
              END {
                if (image != "") {
                  print image "\t" dev "\t" pid
                }
              }
            '
          }

          terminate_pid_soft_then_hard() {
            local pid="$1"
            kill -TERM "${pid}" 2>/dev/null || return 0
            sleep 1
            if kill -0 "${pid}" 2>/dev/null; then
              kill -KILL "${pid}" 2>/dev/null || true
            fi
          }

          cleanup_stale_dmg_state() {
            local dmg_mounts
            dmg_mounts="$(mount | awk -v mount_regex="${rw_dmg_mountpoint_regex}" '
              $1 ~ /^\/dev\/disk/ && $3 ~ mount_regex { print $3 }
            ' || true)"
            if [ -n "${dmg_mounts}" ]; then
              while IFS= read -r mount_point; do
                [ -z "${mount_point}" ] && continue
                echo "Detaching stale mount ${mount_point}"
                detach_target "${mount_point}" || true
              done <<< "${dmg_mounts}"
            fi

            local dmg_records
            dmg_records="$(collect_dmg_records)"

            local workspace_disks
            workspace_disks=""
            local workspace_helper_pids
            workspace_helper_pids=""
            while IFS=$'\t' read -r image disk pid; do
              [ -z "${image:-}" ] && continue
              if ! is_workspace_rw_dmg_image "${image}"; then
                continue
              fi
              if [[ "${disk}" =~ ^/dev/disk[0-9]+$ ]]; then
                workspace_disks+="${disk}"$'\n'
              fi
              if [[ "${pid}" =~ ^[0-9]+$ ]]; then
                workspace_helper_pids+="${pid}"$'\n'
              fi
            done <<< "${dmg_records}"
            workspace_disks="$(printf '%s\n' "${workspace_disks}" | awk 'NF' | sort -u)"
            workspace_helper_pids="$(printf '%s\n' "${workspace_helper_pids}" | awk 'NF' | sort -u)"

            if [ -n "${workspace_disks}" ]; then
              while IFS= read -r disk; do
                [ -z "${disk}" ] && continue
                echo "Detaching stale disk ${disk}"
                detach_target "${disk}" || true
              done <<< "${workspace_disks}"
            fi

            # Prefer process IDs linked to this workspace's RW DMG images.
            local helper_pids
            helper_pids="${workspace_helper_pids}"

            # Fallback: exact process-name match only, avoid broad -f substring patterns.
            if [ -z "${helper_pids}" ] && [ "${allow_global_helper_cleanup}" = "1" ]; then
              helper_pids="$(
                pgrep -x diskimages-helper || true
                pgrep -x diskimages-help || true
              )"
            elif [ -z "${helper_pids}" ]; then
              echo "Skip global disk image helper cleanup (set ASTRBOT_DESKTOP_MACOS_ALLOW_GLOBAL_HELPER_KILL=1 to enable)." >&2
            fi
            helper_pids="$(printf '%s\n' "${helper_pids}" | awk 'NF' | sort -u)"
            if [ -n "${helper_pids}" ]; then
              while IFS= read -r pid; do
                [ -z "${pid}" ] && continue
                echo "Killing stale disk image helper pid=${pid}"
                terminate_pid_soft_then_hard "${pid}"
              done <<< "${helper_pids}"
            fi
          }

          while [ "${attempt}" -le "${max_attempts}" ]; do
            echo "Cleaning stale DMG state before attempt ${attempt}/${max_attempts}..."
            cleanup_stale_dmg_state

            log_file="$(mktemp -t tauri-macos-build.XXXXXX.log)"
            echo "macOS build attempt ${attempt}/${max_attempts} (arch=${{ matrix.arch }}, target=${{ matrix.target }})"

            if cargo tauri build --verbose --target ${{ matrix.target }} 2>&1 | tee "${log_file}"; then
              exit 0
            fi

            if [ "${attempt}" -ge "${max_attempts}" ]; then
              echo "macOS build failed after ${max_attempts} attempts."
              exit 1
            fi

            if ! grep -Eq "${retry_pattern}" "${log_file}"; then
              echo "macOS build failed with a non-retryable error. Skip retry."
              exit 1
            fi

            echo "Detected transient DMG detach/bundling error. Cleaning up stale dmg mounts before retry..."
            cleanup_stale_dmg_state
            rm -f src-tauri/target/${{ matrix.target }}/release/bundle/macos/rw.*.dmg || true
            cleanup_log_file

            attempt=$((attempt + 1))
            sleep 5
          done

      - name: Dump macOS bundling diagnostics
        if: steps.build_macos.outcome == 'failure'
        shell: bash
        run: |
          set -euo pipefail

          dmg_dir="src-tauri/target/${{ matrix.target }}/release/bundle/dmg"
          script_path="${dmg_dir}/bundle_dmg.sh"

          echo "::group::DMG output directory listing"
          ls -la "${dmg_dir}" || true
          echo "::endgroup::"

          if [ -f "${script_path}" ]; then
            echo "::group::bundle_dmg.sh"
            nl -ba "${script_path}" || cat "${script_path}"
            echo "::endgroup::"

            echo "::group::bundle_dmg.sh trace (bash -x)"
            (
              cd "${dmg_dir}"
              bash -x ./bundle_dmg.sh
            ) || true
            echo "::endgroup::"
          else
            echo "bundle_dmg.sh not found at ${script_path}"
          fi

          echo "::group::System diagnostics"
          uname -a || true
          sw_vers || true
          xcodebuild -version || true
          df -h || true
          hdiutil info || true
          echo "::endgroup::"

      - name: Fail macOS build when bundling fails
        if: steps.build_macos.outcome == 'failure'
        shell: bash
        run: |
          echo "macOS build failed, diagnostics are printed above."
          exit 1

      - name: Verify macOS DMG integrity
        if: steps.build_macos.outcome == 'success'
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          dmg_files=(src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg)
          if [ "${#dmg_files[@]}" -eq 0 ]; then
            echo "No DMG files found under src-tauri/target/${{ matrix.target }}/release/bundle/dmg"
            exit 1
          fi

          for dmg in "${dmg_files[@]}"; do
            echo "Verifying ${dmg}"
            hdiutil verify "${dmg}"
          done

      - name: Upload artifacts
        if: steps.build_macos.outcome == 'success'
        uses: actions/upload-artifact@v6.0.0
        with:
          name: astrbot-desktop-tauri-${{ needs.resolve_build_context.outputs.astrbot_version }}-macos-${{ matrix.arch }}
          if-no-files-found: error
          path: |
            src-tauri/target/${{ matrix.target }}/release/bundle/dmg/*.dmg
            src-tauri/target/${{ matrix.target }}/release/bundle/**/*.app.tar.gz

  build-windows:
    needs:
      - resolve_build_context
      - sync_repo_version
    if: ${{ always() && needs.resolve_build_context.outputs.should_build == 'true' && (needs.sync_repo_version.result == 'success' || needs.sync_repo_version.result == 'skipped') }}
    name: windows-${{ matrix.arch }}
    runs-on: ${{ matrix.runner }}
    env:
      WINDOWS_INSTALLER_EXE_GLOBS: |
        src-tauri/target/release/bundle/nsis-web/*.exe
        src-tauri/target/release/bundle/nsis/*.exe
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: amd64
            runner: windows-2022
          - arch: arm64
            runner: windows-11-arm

    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.2

      - name: Setup desktop build environment
        uses: ./.github/actions/setup-desktop-build

      - name: Build desktop installers (Windows)
        env:
          ASTRBOT_SOURCE_GIT_URL: ${{ needs.resolve_build_context.outputs.source_git_url }}
          ASTRBOT_SOURCE_GIT_REF: ${{ needs.resolve_build_context.outputs.source_git_ref }}
          ASTRBOT_DESKTOP_VERSION: ${{ needs.resolve_build_context.outputs.astrbot_version }}
          ASTRBOT_DESKTOP_CRYPTOGRAPHY_FALLBACK_VERSIONS: ${{ vars.ASTRBOT_DESKTOP_CRYPTOGRAPHY_FALLBACK_VERSIONS || '' }}
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ github.token }}
        run: pnpm run build

      - name: Upload artifacts
        uses: actions/upload-artifact@v6.0.0
        with:
          name: astrbot-desktop-tauri-${{ needs.resolve_build_context.outputs.astrbot_version }}-windows-${{ matrix.arch }}
          if-no-files-found: error
          # Only upload Windows installer executables.
          # A broad **/*.exe pattern also matches bundled Python runtime helpers.
          path: |
            src-tauri/target/release/bundle/**/*.msi
            ${{ env.WINDOWS_INSTALLER_EXE_GLOBS }}

  release:
    name: Publish GitHub Release
    if: ${{ needs.resolve_build_context.outputs.should_build == 'true' && (github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish_release == 'true')) }}
    needs:
      - resolve_build_context
      - build-linux
      - build-macos
      - build-windows
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6.0.2

      - name: Download build artifacts
        uses: actions/download-artifact@v7.0.0
        with:
          pattern: astrbot-desktop-tauri-${{ needs.resolve_build_context.outputs.astrbot_version }}-*
          path: release-artifacts
          merge-multiple: true

      - name: Show artifacts
        run: find release-artifacts -type f | sort

      - name: Validate artifact filename uniqueness
        shell: bash
        run: |
          set -euo pipefail
          python3 scripts/ci/validate-release-artifacts.py release-artifacts

      - name: Create or update release
        uses: softprops/action-gh-release@v2.5.0
        with:
          tag_name: v${{ needs.resolve_build_context.outputs.astrbot_version }}
          name: AstrBot Desktop v${{ needs.resolve_build_context.outputs.astrbot_version }}
          body: |
            Automated desktop package release.
            - Source: `${{ needs.resolve_build_context.outputs.source_git_url }}`
            - Ref: `${{ needs.resolve_build_context.outputs.source_git_ref }}`
            - Windows tip: prefer `nsis-web` installer for smaller downloads and faster install startup.
          generate_release_notes: true
          files: release-artifacts/**/*
          fail_on_unmatched_files: true
